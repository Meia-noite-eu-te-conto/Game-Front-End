<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Room List Page</title>

	<link rel="stylesheet" href="./assets/css/background.css" />

	<link rel="icon" type="image/png" href="/assets/icon/favicon-96x96.png" sizes="96x96" />
	<link rel="icon" type="image/svg+xml" href="/assets/icon/favicon.svg" />
	<link rel="shortcut icon" href="/assets/icon/favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="/assets/icon/apple-touch-icon.png" />

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
	
    <script src="/assets/js/Enums.js"></script>
	<script src="/assets/js/WebglUtils.js"></script>
	<script src="/assets/js/MVnew.js"></script>
    <script src="./assets/js/utils/CustomError.js"></script>
    <script src="./assets/js/repositories/RoutesInfo.js"></script>
    <script src="/assets/js/Generics.js"></script>

    <script src="./assets/js/components/PaginationComponent.js"></script>
    
    <script src="./assets/js/components/HeaderComponent.js"></script>
    <script src="./assets/js/Header.js"></script>

    <script src="./assets/js/repositories/RoomRepository.js"></script>
    <script src="./assets/js/components/RoomComponent.js"></script>
    <script src="./assets/js/Rooms.js"></script>

</head>
<body class="pbg">

	<!-- Header Section -->
	<section id="header-section" class="cover-container bg-light mb-4 d-flex w-100 px-3 mx-auto flex-column"></section>

	<main style="height: 85vh;" class="my-5 container">
		<div class="d-flex flex-column align-items-center">
			<canvas width="850px" height="550px" class="bg-light border border-dark" id="myCanvas"></canvas>
		</div>
		<div class="d-flex ">
			<div id="list-of-players" class="w-75 my-2 list-group list-group-flush d-flex flex-row align-items-center">
				<a href="#" class="me-3 list-group-item list-group-item-action py-3 lh-sm rounded-4 mb-2">
					<div class="d-flex w-100 align-items-center justify-content-between">
						<div class="d-flex w-75 align-items-center">
							<img class="rounded-circle img-thumbnail bg-primary" src="./assets/img/1.png" alt="">
							<div class="d-flex flex-column ps-2 justify-content-center">
								<strong class="mb-1">Carlinhos</strong>
								<p class="small mb-0">Blue</p>
							</div>
						</div>
						<h3 class="text-body-secondary">4</h3>
					</div>
				</a>
				<h1 class="me-3">X</h1>
				<a href="#" class="list-group-item list-group-item-action py-3 lh-sm rounded-4 mb-2">
					<div class="d-flex w-100 align-items-center justify-content-between">
						<div class="d-flex w-75 align-items-center">
							<img class="rounded-circle img-thumbnail bg-danger" src="./assets/img/2.png" alt="">
							<div class="d-flex flex-column ps-2 justify-content-center">
								<strong class="mb-1">Ranna</strong>
								<p class="small mb-0">Red</p>
							</div>
						</div>
						<h3 class="text-body-secondary">7</h3>
					</div>
				</a>
			</div>
			<div class="w-25 d-flex align-items-center justify-content-end">
				<button class="btn btn-dark">Sair da Partida</button>
			</div>
		</div>
	</main>

	<div class="modal fade" id="gameOverModal" tabindex="-1" aria-labelledby="gameOverModalLabel" aria-hidden="true">
		<div class="modal-dialog">
			<div class="modal-content">
				<div class="modal-header">
					<h5 class="modal-title" id="gameOverModalLabel">Game Over</h5>
					<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
				</div>
				<div class="modal-body">
					The game has ended. Thank you for playing!
				</div>
				<div class="modal-footer">
					<a href="/index.html" type="button" class="btn btn-secondary">Go to initial menu</a>
				</div>
			</div>
		</div>
	</div>
	<script>
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('roomCode');

		const host = window.location.host;

		const gameId = urlParams.get('gameId');
		const endpoint = `/api/v1/game-core/games/${gameId}/`;
		let socket = null

		// Atributos game
		const	NUMBER_OF_PLAYERS = 3;

		// Posição e tamanho das salas e das portas
		const	BALL_POSITION = vec3(0, 0, -96);
		const	BALL_SCALE = vec3(2, 2, 2);
		const	GOALKEEPER_1_POSITION = vec3(-44, 0, -94);
		const	GOALKEEPER_2_POSITION = vec3(44, 0, -94);
		const	GOALKEEPER_SCALE = vec3(2, 16, 8);
		const	FIELD_POSITION = vec3(0, 0, -100);
		if (NUMBER_OF_PLAYERS == 2)
			var	FIELD_SCALE = vec3(90, 60, 4);
		else
			var	FIELD_SCALE = vec3(90, 90, 4);

		// Número de cubos
		const	NUMBER_OF_CUBES = 3;

		// Número de bolas
		const	NUMBER_OF_BALLS = 1;

		// Vértices do cubo centrado na origem de lado 1
		const	CUBE_VERTICES = [
			vec4(-0.5, -0.5, 0.5, 1.0),
			vec4(-0.5, 0.5, 0.5, 1.0),
			vec4(0.5, 0.5, 0.5, 1.0),
			vec4(0.5, -0.5, 0.5, 1.0),
			vec4(-0.5, -0.5, -0.5, 1.0),
			vec4(-0.5, 0.5, -0.5, 1.0),
			vec4(0.5, 0.5, -0.5, 1.0),
			vec4(0.5, -0.5, -0.5, 1.0)
		];

		// Vértices da pirâmide de cima, objeto base para implementar a esfera
		const	SP_POS_VERT = [
			vec4(1.0, 0.0, 0.0, 1),
			vec4(0.0, 1.0, 0.0, 1),
			vec4(0.0, 0.0, 1.0, 1),
		];

		// Vértices da pirâmide de baixo, objeto base para implementar a esfera
		const	SP_NEG_VERT = [
			vec4(-1.0, 0.0, 0.0, 1),
			vec4(0.0, -1.0, 0.0, 1),
			vec4(0.0, 0.0, -1.0, 1),
		];

		// Vértices dos triângulos que são as faces das pirâmides
		const	SP_TRIANGLES = [
			[SP_POS_VERT[0], SP_POS_VERT[1], SP_POS_VERT[2]],
			[SP_POS_VERT[0], SP_NEG_VERT[2], SP_POS_VERT[1]],

			[SP_POS_VERT[0], SP_POS_VERT[2], SP_NEG_VERT[1]],
			[SP_POS_VERT[0], SP_NEG_VERT[1], SP_NEG_VERT[2]],

			[SP_NEG_VERT[0], SP_POS_VERT[2], SP_POS_VERT[1]],
			[SP_NEG_VERT[0], SP_POS_VERT[1], SP_NEG_VERT[2]],

			[SP_NEG_VERT[0], SP_NEG_VERT[1], SP_POS_VERT[2]],
			[SP_NEG_VERT[0], SP_NEG_VERT[2], SP_NEG_VERT[1]],
		];

		// Índices dos objetos
		const	FIELD = 0;
		const	GOALKEEPER_1 = 1;
		const	GOALKEEPER_2 = 2;
		const	BALL = 3;

		// Cores
		const	WHITE = vec4(1, 1, 1, 1);
		const	RED = vec4(1, 0, 0, 1);
		const	GREEN = vec4(0, 1, 0, 1);
		const	BLUE = vec4(0, 0, 1, 1);
		const	FILED_COLOR = GREEN;
		const	GOALKEEPER_1_COLOR = RED;
		const	GOALKEEPER_2_COLOR = BLUE;

		// Propriedades da fonte de luz
		const	LIGHT = {
			pos: vec4(0.0, 40.0, 0.0, 1.0), // posição
			amb: vec4(0.2, 0.2, 0.2, 1.0), // ambiente
			dif: vec4(1.0, 1.0, 1.0, 1.0), // difusão
			spec: vec4(1.0, 1.0, 1.0, 1.0), // especular
		};

		// Propriedades do material
		const	MAT = {
			amb: vec4(0.4, 0.4, 0.4, 1.0),
			dif: vec4(1.0, 1.0, 1.0, 1.0),
			alfa: 50.0, // brilho ou shininess
		};

		// Camera
		const	FOVY = 60;
		const	ASPECT = 1;
		const	NEAR = 0.1 / 500 * 500;
		const	FAR = 5000 / 500 * 500;
		const	EYE = vec3(0, 0, 0);
		const	AT = vec3(0, 0, -1);
		const	DIR = vec3(0, 0, -1);
		const	UP = vec3(0, 1, 0);
		const	CAMERA_VTRANS = 150 / 500 * 500;
		const	CAMERA_THETA = Math.PI / 2;
		const	CAMERA_THETA_DEGREES = CAMERA_THETA * 180 / Math.PI;

		// Constantes globais
		const	BACKGROUND = [0.0, 0.0, 1.0, 0.3];
		const	AXIS_X_IND = 0;
		const	AXIS_Y_IND = 1;
		const	AXIS_Z_IND = 2;
		const	AXIS_X = vec3(1, 0, 0);
		const	AXIS_Y = vec3(0, 1, 0);
		const	AXIS_Z = vec3(0, 0, 1);

		// Textura é um tabuleiro de xadrez 8 x 8
		const	TEX_ROLS = 8;
		const	TEX_COLS = 8;
		const	TEX_SIDE = 128; // lado da imagem textura
		const	TEX_COLOR_SIZE = 4; // RGBA

		// Textura: coordenadas (s, t) entre 0 e 1
		const	vTextura = [
			vec2(0.0, 0.0),
			vec2(0.0, 1.0),
			vec2(1.0, 1.0),
			vec2(1.0, 0.0)
		];
		const	NO_TEXTURE = vec2(-1, -1);

		// Cria array de textura. Pixels costumam ser do tipo Uint8
		var		gTexture = new Uint8Array(TEX_COLOR_SIZE * TEX_SIDE * TEX_SIDE);
		const	URL_BALL = "https://www.google.com/url?sa=i&url=https%3A%2F%2Fbr.freepik.com%2Fvetores-premium%2Fbola-de-fundo-de-futebol-de-textura-panoramica-preto-e-branco-vetor-gratis_26529379.htm&psig=AOvVaw2hSZ8fMihInpGdrvUIbcpH&ust=1733084762766000&source=images&cd=vfe&opi=89978449&ved=0CBQQjRxqFwoTCKCy_IryhIoDFQAAAAAdAAAAABAE"
		const	URLS = [URL_BALL];

		// Variáveis globais
		var		gPong = {
			time: Date.now(),
			running: true,
			step: false,
			delta: 0,
			portalObject: "sphere",
			gravity: -500,
			lightSpeed: 10e10,
		};
		var		gInterface = {};
		var		gl; // webgl2
		var		gCanvas; // canvas

		// Objetos a serem renderizados
		var		gObjects = [];

		// Câmera
		var		gCamera = new Camera();

		// Guarda coisas do shader
		var		gShader = {};

		// Guarda coisas da interface e do contexto do programa
		var		gCtx =
		{
			view: mat4(), // view matrix, inicialmente identidade
			perspective: mat4(), // projection matrix, inicialmente identidade
		};

		// Vetores de atributos dos objetos
		var		gPositions = [];
		var		gColors = [];
		var		gNormals = [];
		var		gTextures = [];

		// Chama a main quando terminar de carregar a janela
		// window.onload = main;

		// Função que cria um cubo
		function	Cube()
		{
			this.draw = true;
			this.numberOfPositions = 0;
			this.positions = [];
			this.normals = [];
			this.colors = [];
			this.textures = [];
			this.text = 0;
			this.pos = vec3(0, 0, 0);
			this.pos2 = vec3(0, 0, 0);
			this.vTrans = vec3(0, 0, 0);
			this.trans = this.pos;
			this.theta = vec3(0, 0, 0);
			this.vTheta = vec3(0, 0, 0);
			this.rot = this.theta;
			this.scale = vec3(1, 1, 1);
			this.v = vec3(0, 0, 0);
			this.model = mat4();
			// Função que inicializa as posições do cubo e sua matriz de transformação
			this.init = function(cube)
			{
				square(this.positions, this.normals, CUBE_VERTICES, 1, 0, 3, 2);
				square(this.positions, this.normals, CUBE_VERTICES, 2, 3, 7, 6);
				square(this.positions, this.normals, CUBE_VERTICES, 3, 0, 4, 7);
				square(this.positions, this.normals, CUBE_VERTICES, 6, 5, 1, 2);
				square(this.positions, this.normals, CUBE_VERTICES, 4, 5, 6, 7);
				square(this.positions, this.normals, CUBE_VERTICES, 5, 4, 0, 1);
				this.numberOfPositions = this.positions.length;
				this.model = mult(scale(this.scale[0], this.scale[1], this.scale[2]), this.model);
				this.model = mult(rotate(this.theta[AXIS_Z_IND], AXIS_Z), this.model);
				this.model = mult(rotate(this.theta[AXIS_Y_IND], AXIS_Y), this.model);
				this.model = mult(rotate(this.theta[AXIS_X_IND], AXIS_X), this.model);
				this.model = mult(translate(this.pos[0], this.pos[1], this.pos[2]), this.model);
			};
			// Função que atualiza a matriz de transformação do cubo
			this.updateModel = function(cube)
			{
				this.model = mat4();
				this.model = mult(scale(this.scale[0], this.scale[1], this.scale[2]), this.model);
				this.model = mult(rotate(this.rot[AXIS_Z_IND], AXIS_Z), this.model);
				this.model = mult(rotate(this.rot[AXIS_Y_IND], AXIS_Y), this.model);
				this.model = mult(rotate(this.rot[AXIS_X_IND], AXIS_X), this.model);
				this.trans = add(this.trans, mult(gPong.delta, this.vTrans));
				this.pos2 = add(this.pos, this.trans);
				this.model = mult(translate(this.pos2[0], this.pos2[1], this.pos2[2]), this.model);
			};
		};

		// Função que, dado um quadrado, divide-o em dois triângulos,
		// calcula a normal do quadrado e adiciona suas posições e normal
		// em seus respectivos vetores
		function	square(positions, normals, vertices, a, b, c, d)
		{
			var	t1 = subtract(vertices[b], vertices[a]);
			var	t2 = subtract(vertices[c], vertices[b]);
			var	normal = cross(t1, t2);
			normal = vec3(normal);

			positions.push(vertices[a]);
			normals.push(normal);
			positions.push(vertices[b]);
			normals.push(normal);
			positions.push(vertices[c]);
			normals.push(normal);
			positions.push(vertices[a]);
			normals.push(normal);
			positions.push(vertices[c]);
			normals.push(normal);
			positions.push(vertices[d]);
			normals.push(normal);
		};

		// Função que cria uma esfera
		function	Sphere(numberOfDivisions = 4)
		{
			this.draw = true;
			this.numberOfPositions = 0;
			this.positions = [];
			this.normals = [];
			this.colors = [];
			this.textures = [];
			this.text = 0;
			this.pos = vec3(0, 0, 0);
			this.pos2 = vec3(0, 0, 0);
			this.vTrans = vec3(1, 1, 0);
			this.bounciness = 1;
			this.trans = this.pos;
			this.theta = vec3(0, 0, 0);
			this.vTheta = vec3(0, 0, 0);
			this.vTheta1 = vec3(0, 0, 0);
			this.rot = this.theta;
			this.rot1 = this.theta;
			this.scale = vec3(1, 1, 1);
			this.v = vec3(0, 0, 0);
			this.model = mat4();
			// Função que inicializa as posições da esfera e sua matriz de transformação
			this.init = function()
			{
				this.pos2 = this.pos;
				for (let i = 0; i < SP_TRIANGLES.length; i++)
				{
					let	a, b, c;
					[a, b, c] = SP_TRIANGLES[i];
					splitTriangles(a, b, c, numberOfDivisions, this.positions, this.normals);
				}
				this.numberOfPositions = this.positions.length;
				this.model = mult(scale(this.scale[0], this.scale[1], this.scale[2]), this.model);
				this.model = mult(rotate(this.theta[AXIS_Z_IND], AXIS_Z), this.model);
				this.model = mult(rotate(this.theta[AXIS_Y_IND], AXIS_Y), this.model);
				this.model = mult(rotate(this.theta[AXIS_X_IND], AXIS_X), this.model);
				this.model = mult(translate(this.pos[0], this.pos[1], this.pos[2]), this.model);
			};
			// Função que atualiza a matriz de transformação da esfera
			this.updateModel = function(sphere)
			{
				this.model = mat4();
				this.model = mult(scale(this.scale[0], this.scale[1], this.scale[2]), this.model);
				this.rot = add(this.rot, mult(gPong.delta, this.vTheta));
				this.model = mult(rotate(this.rot[AXIS_Z_IND], AXIS_Z), this.model);
				this.model = mult(rotate(this.rot[AXIS_Y_IND], AXIS_Y), this.model);
				this.model = mult(rotate(this.rot[AXIS_X_IND], AXIS_X), this.model);
				// if ((this.pos[0] <= -41 && this.pos[1] <= gObjects[GOALKEEPER_1].pos[1] + 8 && this.pos[1] >= gObjects[GOALKEEPER_1].pos[1] - 8) ||
				// 		(this.pos[0] >= 41 && this.pos[1] <= gObjects[GOALKEEPER_2].pos[1] + 8 && this.pos[1] >= gObjects[GOALKEEPER_2].pos[1] - 8))
				// 	this.vTrans[0] *= -1;
				// else if (this.pos[0] <= -43 || this.pos[0] >= 43)
				// 	this.pos = vec3(0, 0, -96);
				// if (this.pos[1] <= -28 || this.pos[1] >= 28)
				// 	this.vTrans[1] *= -1;
				this.trans = add(this.pos, mult(gPong.delta, this.vTrans));
				this.pos = this.trans;
				this.model = mult(translate(this.trans[0], this.trans[1], this.trans[2]), this.model);
			};
			// Função que verifica colisões entre uma esfera e as paredes da sala
			this.checkCollision = function(sphere)
			{
				for (let i = 0; i <= 2; i++)
				{
					if (gObjects[sphere].pos2[i] >= -COLLISION_RADIO + gObjects[ROOM_2].pos[i] + 500 / 2)
					{
						this.vTrans[i] *= -1 * this.bounciness;
						this.pos2[i] = -COLLISION_RADIO + gObjects[ROOM_2].pos[i] + 500 / 2;
					}
					else if (gObjects[sphere].pos2[i] <= gObjects[ROOM_2].pos[i] - 500 / 2 + COLLISION_RADIO)
					{
						this.vTrans[i] *= -1 * this.bounciness;
						this.pos2[i] = gObjects[ROOM_2].pos[i] - 500 / 2 + COLLISION_RADIO;
					}
				}
			};
		};

		// Função recursiva que, dado uma face de uma das pirâmides base da esfera,
		// divide-a em uma potência de quatro triângulos e, depois calcula a normal
		// do triângulo e adiciona suas posições e normal em seus respectivos vetores
		function	splitTriangles(a, b, c, numberOfDivisions, positions, normals)
		{
			if (numberOfDivisions > 0)
			{
				let	ab = mix(a, b, 0.5);
				let	bc = mix(b, c, 0.5);
				let	ca = mix(c, a, 0.5);

				ab = normalize(ab, true);
				bc = normalize(bc, true);
				ca = normalize(ca, true);

				splitTriangles(a, ab, ca, numberOfDivisions - 1, positions, normals);
				splitTriangles(b, bc, ab, numberOfDivisions - 1, positions, normals);
				splitTriangles(c, ca, bc, numberOfDivisions - 1, positions, normals);
				splitTriangles(ab, bc, ca, numberOfDivisions - 1, positions, normals);
			}
			else
			{
				var	t1 = subtract(b, a);
				var	t2 = subtract(c, a);
				var	normal = cross(t1, t2);
				normal = vec3(normal);

				positions.push(a);
				normals.push(normal);
				positions.push(b);
				normals.push(normal);
				positions.push(c);
				normals.push(normal);
			}
		};

		// Função que cria a câmera
		function	Camera()
		{
			this.pos = EYE;
			this.at = AT;
			this.dir = DIR;
			this.dir4 = vec4(0, 0, 0, 0);
			this.up = UP;
			this.theta = vec3(0, 0, 0);
			this.vTrans = 0;
			this.trans = vec3(0, 0, 0);
			this.recalculateView = false;
			// Função que atualiza a matriz view da esfera
			// por meio de uma matriz de transformação
			this.updateView = function()
			{
				if (this.recalculateView == true)
				{
					let	transform = mat4();

					transform = mult(rotate(this.theta[AXIS_Z_IND], AXIS_Z), transform);
					transform = mult(rotate(this.theta[AXIS_Y_IND], AXIS_Y), transform);
					transform = mult(rotate(this.theta[AXIS_X_IND], AXIS_X), transform);
					this.theta = vec3(0, 0, 0);
					this.dir4 = vec4(this.dir[0], this.dir[1], this.dir[2], 0);
					this.trans = mult(gPong.delta * this.vTrans, this.dir4);
					this.vTrans = 0;
					transform = mult(translate(this.trans[0], this.trans[1], this.trans[2]), transform);
					gCtx.view = mult(transform, gCtx.view);
					gl.uniformMatrix4fv(gShader.uView, false, flatten(gCtx.view));
					this.recalculateView = false;
				}
			};
		};

		gCanvas = document.getElementById('myCanvas');
		gl = gCanvas.getContext('webgl2');
		var sim = true;

		function drawOnCanvas(data)
		{
			if (sim)
			{
				
				// Interface
				// Textura
				// createTexture();
				// Objetos
				createObjects();
				initObjects();
				insertAttributes();
				// Inicializações feitas apenas 1 vez
				gl.viewport(0, 0, gCanvas.width, gCanvas.height);
				gl.clearColor(BACKGROUND[0], BACKGROUND[1], BACKGROUND[2], BACKGROUND[3]);
				gl.enable(gl.DEPTH_TEST);
				// Shaders
				console.log("OI");
				createShaders();
				// Finalmente...
				sim = false;
			}
			const	parsedData = JSON.parse(data);
			const	{ players, ball, numberOfPlayers } = parsedData;
			//console.log(players);
			render(players, ball);
		}

		// Função que cria uma imagem quadriculada para ser usada como textura
		function	createTexture()
		{
			// Varre e carrega o array
			for (let i = 0, ind = 0; i < TEX_SIDE; i++)
			{
				let	squareX = Math.floor(i / (TEX_SIDE / TEX_ROLS));

				for (let j = 0; j < TEX_SIDE; j++)
				{
					let	squareY = Math.floor(j / (TEX_SIDE / TEX_COLS));
					let	c = (squareX % 2 != squareY % 2 ? 255 : 0);

					gTexture[ind++] = c;
					gTexture[ind++] = 0;
					gTexture[ind++] = 0;
					gTexture[ind++] = 255;
				};
			};
		};

		// Função que cria os objetos
		function	createObjects()
		{
			for (let i = 0; i < 3; i++)
				gObjects.push(new Cube());
			gObjects.push(new Sphere());
		};

		// Função que inicializa os objetos
		function	initObjects(players)
		{
			initField();
			initKeepers();
			initBall();
		};

		// Função que inicializa a Sala dos Troféus
		function	initField()
		{
			let	text = 5;
			
			gObjects[FIELD].pos = vec3(0, 0, -100);
			gObjects[FIELD].scale = vec3(90, 60, 4);
			gObjects[FIELD].init();
			// gObjects[FIELD].text = text;
			for (let j = 0; j < gObjects[FIELD].numberOfPositions; j++)
			{
				gObjects[FIELD].colors.push(vec4(0, 1, 0, 1));
				gObjects[FIELD].textures.push(NO_TEXTURE);
			}
			// for (let j = 0; j < 6; j++)
			// {
			// 	gObjects[FIELD].color.push(vTextura[0]);
			// 	gObjects[FIELD].textures.push(vTextura[1]);
			// 	gObjects[FIELD].textures.push(vTextura[2]);
			// 	gObjects[FIELD].textures.push(vTextura[0]);
			// 	gObjects[FIELD].textures.push(vTextura[2]);
			// 	gObjects[FIELD].textures.push(vTextura[3]);
			// }
		};

		// Função que inicializa a Sala do Portal
		function	initKeepers()
		{
			gObjects[GOALKEEPER_1].pos = vec3(-44, 0, -94);
			gObjects[GOALKEEPER_1].scale = vec3(2, 16, 8);
			gObjects[GOALKEEPER_1].init();
			for (let j = 0; j < gObjects[GOALKEEPER_1].numberOfPositions; j++)
			{
				gObjects[GOALKEEPER_1].colors.push(vec4(1, 0, 0, 1));
				gObjects[GOALKEEPER_1].textures.push(NO_TEXTURE);
			}

			gObjects[GOALKEEPER_2].pos = vec3(44, 0, -94);
			gObjects[GOALKEEPER_2].scale = vec3(2, 16, 8);
			gObjects[GOALKEEPER_2].init();
			for (let j = 0; j < gObjects[GOALKEEPER_2].numberOfPositions; j++)
			{
				gObjects[GOALKEEPER_2].colors.push(vec4(0, 0, 1, 1));
				gObjects[GOALKEEPER_2].textures.push(NO_TEXTURE);
			}
		};

		// Função que inicializa a Sala do Portal
		function	initBall()
		{
			gObjects[BALL].pos = vec3(0, 0, -96);
			gObjects[BALL].scale = vec3(2, 2, 2);
			gObjects[BALL].vTrans = vec3(randomizeInt(10, 20), randomizeInt(10, 20), 0);
			gObjects[BALL].init();
			for (let j = 0; j < gObjects[BALL].numberOfPositions; j++)
			{
				gObjects[BALL].colors.push(WHITE);
				gObjects[BALL].textures.push(NO_TEXTURE);
			}
		};

		// Função de insere os atributos dos objetos nas respectivas variáveis globais
		function	insertAttributes()
		{
			for (let i = 0; i < 4; i++)
			{
				for (let j = 0; j < gObjects[i].numberOfPositions; j++)
				{
					gPositions.push(gObjects[i].positions[j]);
					gColors.push(gObjects[i].colors[j]);
					gNormals.push(gObjects[i].normals[j]);
					gTextures.push(gObjects[i].textures[j]);
				}
			}
		};

		// Função que cria e configura os shaders
		function	createShaders()
		{
			// Cria o programa
			gShader.program = makeProgram(gl, gVertexShaderSrc, gFragmentShaderSrc);
			gl.useProgram(gShader.program);

			// Cria e configura os buffers dos objetos
			createBuffers();

			// Resolve os uniforms
			gShader.uModel = gl.getUniformLocation(gShader.program, "uModel");
			gShader.uView = gl.getUniformLocation(gShader.program, "uView");
			gShader.uPerspective = gl.getUniformLocation(gShader.program, "uPerspective");
			gShader.uInverseTranspose = gl.getUniformLocation(gShader.program, "uInverseTranspose");

			// Calcula a matriz de transformação perpectiva (fovy, aspect, near, far)
			gCtx.perspective = perspective(FOVY, ASPECT, NEAR, FAR);
			gl.uniformMatrix4fv(gShader.uPerspective, false, flatten(gCtx.perspective));

			// Calcula a matriz view (pos, at, up)
			gCtx.view = lookAt(gCamera.pos, gCamera.at, gCamera.up);
			gl.uniformMatrix4fv(gShader.uView, false, flatten(gCtx.view));

			// Parâmetros para iluminação
			gShader.uLightPos = gl.getUniformLocation(gShader.program, "uLightPos");
			gl.uniform4fv(gShader.uLightPos, LIGHT.pos);

			// Fragment shader
			gShader.uAmbColor = gl.getUniformLocation(gShader.program, "uAmbColor");
			gShader.uDifColor = gl.getUniformLocation(gShader.program, "uDifColor");
			gShader.uSpecColor = gl.getUniformLocation(gShader.program, "uSpecColor");
			gShader.uAlphaSpec = gl.getUniformLocation(gShader.program, "uAlphaSpec");

			gl.uniform1f(gShader.uAlphaSpec, gCtx.alfaEspecular);
			gl.uniform4fv(gShader.uAmbColor, mult(LIGHT.amb, MAT.amb));
			gl.uniform4fv(gShader.uDifColor, mult(LIGHT.dif, MAT.dif));
			gl.uniform4fv(gShader.uSpecColor, LIGHT.spec);
			gl.uniform1f(gShader.uAlphaSpec, MAT.alfa);

			gShader.uTextureMap = gl.getUniformLocation(gShader.program, "uTextureMap");

			setUpTexture(gTexture, URLS.length);
			for (let i = 0; i < URLS.length; i++)
				setUpURLTexture(URLS[i], i);
		};

		function	createBuffers(obj)
		{
			// Buffer dos vértices
			let	bufPositions = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, bufPositions);
			gl.bufferData(gl.ARRAY_BUFFER, flatten(gPositions), gl.STATIC_DRAW);

			// Vincula o buffer de vértices e configura o atributo
			var	aPosition = gl.getAttribLocation(gShader.program, "aPosition");
			gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(aPosition);

			// Buffer das cores
			let	bufColors = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, bufColors);
			gl.bufferData(gl.ARRAY_BUFFER, flatten(gColors), gl.STATIC_DRAW);

			// Vincula o buffer de cores e configura o atributo
			var	aColor = gl.getAttribLocation(gShader.program, "aColor");
			gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(aColor);

			// Buffer das normais
			let	bufNormals = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, bufNormals);
			gl.bufferData(gl.ARRAY_BUFFER, flatten(gNormals), gl.STATIC_DRAW);

			// Vincula o buffer de normais e configura o atributo
			var	aNormal = gl.getAttribLocation(gShader.program, "aNormal");
			gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(aNormal);

			// Buffer de textura
			let	bufTextures = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, bufTextures);
			gl.bufferData(gl.ARRAY_BUFFER, flatten(gTextures), gl.STATIC_DRAW);

			// Vincula o buffer de textura e configura o atributo
			var aTextCoord = gl.getAttribLocation(gShader.program, "aTextCoord");
			gl.vertexAttribPointer(aTextCoord, 2, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(aTextCoord);
		};

		function	setUpURLTexture(url, textureUnit)
		{
			var	texture = gl.createTexture();
			gl.activeTexture(gl[`TEXTURE${textureUnit}`]);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));

			var	img = new Image();
			img.src = url;
			img.crossOrigin = "anonymous";
			img.addEventListener('load', function()
			{
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, img.width, img.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
				gl.generateMipmap(gl.TEXTURE_2D);
			});
			return (texture);
		};

		function	setUpTexture(img, textureUnit)
		{
			let	texture = gl.createTexture();
			gl.activeTexture(gl[`TEXTURE${textureUnit}`]);
			gl.bindTexture(gl.TEXTURE_2D, texture);

			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TEX_SIDE, TEX_SIDE, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
			gl.generateMipmap(gl.TEXTURE_2D);

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
		};

		// Função que renderiza as imagens
		function	render(players, ball)
		{
			let	time = Date.now();

			gPong.delta = (time - gPong.time) / 1000;
			if (gPong.step)
				gPong.delta = 0.3;
			if (!gPong.running && !gPong.step)
				gPong.delta = 0;
			gPong.time = time;
			gPong.step = false;
			updateObjects(players, ball);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// Configura e desenha os objetos
			let	begin = 0;

			for (let i = 0; i < 4; i++)
			{
				if (gObjects[i].draw)
				{
					calculateMatrices(gObjects[i]);
					gl.drawArrays(gl.TRIANGLES, begin, gObjects[i].numberOfPositions);
				}
				begin += gObjects[i].numberOfPositions;
			}
			//window.requestAnimationFrame(render);
		};

		function	updateObjects(players, ball)
		{
			gObjects[GOALKEEPER_1].pos[1] = players["0"].y;
			gObjects[GOALKEEPER_2].pos[1] = players["1"].y;
			gObjects[BALL].pos[0] = ball.x;
			gObjects[BALL].pos[1] = ball.y;
			// vec3(players["0"].x, players["0"].y, players["0"].z);
			//gObjects[GOALKEEPER_2].pos = gObjects[GOALKEEPER_2].pos + vec3(1, 0 , 0);
			//  = vec3(players["1"].x, players["1"].y, players["1"].z);
			gCamera.updateView();
			for(let i = 0; i < 4; i++)
				gObjects[i].updateModel();
		};

		// Função que calcula a matriz transposta e multiplica pelas normais
		function	calculateMatrices(obj)
		{
			let modelView = mult(gCtx.view, obj.model);
			let	modelViewInv = inverse(modelView);
			let	modelViewInvTrans = transpose(modelViewInv);

			gl.uniformMatrix4fv(gShader.uModel, false, flatten(obj.model));
			gl.uniformMatrix4fv(gShader.uInverseTranspose, false, flatten(modelViewInvTrans));
			gl.uniform1i(gShader.uTextureMap, obj.text);
		};

		// Código fonte dos shaders em GLSL
		// A primeira linha deve conter "#version 300 es" para WebGL 2.0
		var gVertexShaderSrc = `#version 300 es

		in vec4			aPosition;
		in vec4			aColor;
		in vec3			aNormal;
		in vec2			aTextCoord;

		uniform mat4	uModel;
		uniform mat4	uView;
		uniform mat4	uPerspective;
		uniform mat4	uInverseTranspose;
		uniform vec4	uLightPos;

		out vec3		vNormal;
		out vec3		vLight;
		out vec3		vView;
		out vec4		vColor;
		out vec2		vTextCoord;

		void	main()
		{
			mat4	modelView = uView * uModel;
			gl_Position = uPerspective * modelView * aPosition;

			vNormal = mat3(uInverseTranspose) * aNormal;
			vec4	pos = modelView * aPosition;

			vLight = (uView * uLightPos - pos).xyz;
			vView = -(pos.xyz);
			vColor = aColor;
			vTextCoord = aTextCoord;
		}`;

		var	gFragmentShaderSrc = `#version 300 es

		precision highp float;

		in vec3				vNormal;
		in vec3				vLight;
		in vec3				vView;
		in vec4				vColor;
		in vec2				vTextCoord;

		uniform vec4		uAmbColor;
		uniform vec4		uDifColor;
		uniform vec4		uSpecColor;
		uniform float		uAlphaSpec;
		uniform sampler2D	uTextureMap;

		out vec4			finalColor;

		void main()
		{
			vec3	normalV = normalize(vNormal);
			vec3	lightV = normalize(vLight);
			vec3	viewV = normalize(vView);
			vec3	halfV = normalize(lightV + viewV);
			vec4	vColorAux = vColor;

			if (vTextCoord.x != -1.0)
				vColorAux *= texture(uTextureMap, vTextCoord);
			float	kd = max(0.0, dot(normalV, lightV));
			vec4	difuse = kd * uDifColor * vColorAux;

			float	ks = pow(max(0.0, dot(normalV, halfV)), uAlphaSpec);
			vec4	specular = vec4(0, 0, 0, 1);

			if (kd > 0.0)
				specular = ks * uSpecColor;
			finalColor = difuse + specular + uAmbColor * vColorAux;
			finalColor.a = 1.0;
		}`;

		// Função para enviar comandos do teclado
		function sendKey(event) {
			const key = event.key;  // Captura a tecla pressionada
			let userId = getCookie(document, "userId"); 
			 // Obtém o ID do usuário do cookie
			console.log(`Tecla pressionada: ${userId} ${key}`);
			socket.send(JSON.stringify({
				direction: key,
				headers: { "X-User-Id": userId }
			}));
		}

		// Adiciona um listener para o evento de teclado
		document.addEventListener('keydown', sendKey);

		window.onload = function() {
            //redirectIfuserIsActived(document, window)
			renderHeader(document)
			getPlayer()
			socket = new WebSocket(`wss://${host}${endpoint}`);
			socket.onopen = function(event) {
				console.log("Conectado ao servidor WebSocket");
				const userId = getCookie(document, "userId");  // Substitua pelo ID do usuário real
				const headers = { "X-User-Id": userId };

				socket.send(JSON.stringify({
					type: 'connect',
					headers: headers
				}));
			};

			socket.onmessage = function(event) {
				const data = JSON.parse(event.data);
				console.log(event.data);
				if (data.type == 'game.update') {
					drawOnCanvas(data.game_state);
				}

				if (data.type === "update_score") {
					let playerColor = data.playerColor
					let element = document.getElementById(`player-${playerColor}`)
					element.innerHTML = data.playerScore
				}

				if (data.type === "game_finished") {
					const gameOverModal = new bootstrap.Modal(document.getElementById('gameOverModal'));
					gameOverModal.show();
				}
			};

			socket.onclose = function(event) {
				console.log("Desconectado do servidor WebSocket");
			};

			socket.onerror = function(error) {
				console.error("WebSocket error:", error);
			};
		}
		
		function getPlayer() {
			console.log("GET PLAYER")
			fetch(`/api/v1/user-session/players/game/${roomCode}/`, {
					method: 'GET',
				})
					.then(response => response.json())
					.then(data => {
						const playerListElement = document.getElementById("list-of-players")

						playerListElement.innerHTML = ""
						players = data["players"]
						players.sort((a, b) => a.profileColor - b.profileColor);
						players.forEach(player => {
							const playerElement = document.createElement('div');
							playerElement.classList.add("list-group-item", "list-group-item-action", "py-3", "lh-sm", "rounded-4", "mb-2")

							playerElement.innerHTML = `
								<div class="d-flex w-100 align-items-center justify-content-between">
									<div class=" d-flex w-75 align-items-center">
										<img style='background-color: ${PlayerColor[player.profileColor]}' class="rounded-circle img-thumbnail" src="${player.urlProfileImage}" alt="">
										<div class="d-flex flex-column  ps-2 justify-content-center">
											<strong class="mb-1">${player.name}</strong>
											<p class="small mb-0">Blue</p>
										</div>
									</div>
									<h3 id="player-${player.profileColor}" class="text-body-secondary">${player.score}</h3>
								</div>
								`;
							playerListElement.appendChild(playerElement)
						});
					})
			console.log("GET PLAYER END")
		}

	</script>
</body>
</html>